/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 *     __   __)  __     __)     _                                                    *
 *    (, ) /    (, /   /    ___/__)                                                  *
 *      /(        /   /    (, /    _     _ _   _ __                                  *
 *   ) /  \_  o  /   /    o  /   _(/_(_(_(/___(/_/ (_                                *
 *  (_/     JJJJ(___(_J     (_____CCCCCCCCHHHHHHHHH     HHHHHHHHHRRRRRRRRRRRRRRRRR   *
 *         J:::::::::J   CCC::::::::::::CH:::::::H     H:::::::HR::::::::::::::::R   *
 *         J:::::::::J CC:::::::::::::::CH:::::::H     H:::::::HR::::::RRRRRR:::::R  *
 *         JJ:::::::JJC:::::CCCCCCCC::::CHH::::::H     H::::::HHRR:::::R     R:::::R *
 *           J:::::J C:::::C       CCCCCC  H:::::H     H:::::H    R::::R     R:::::R *
 *           J:::::JC:::::C                H:::::H     H:::::H    R::::R     R:::::R *
 *           J:::::JC:::::C                H::::::HHHHH::::::H    R::::RRRRRR:::::R  *
 *           J:::::JC:::::C                H:::::::::::::::::H    R:::::::::::::RR   *
             J:::::JC:::::C                H:::::::::::::::::H    R::::RRRRRR:::::R  *
 JJJJJJJ     J:::::JC:::::C                H::::::HHHHH::::::H    R::::R     R:::::R *
 J:::::J     J:::::JC:::::C                H:::::H     H:::::H    R::::R     R:::::R *
 J::::::J   J::::::J C:::::C       CCCCCC  H:::::H     H:::::H    R::::R     R:::::R *
 J:::::::JJJ:::::::J  C:::::CCCCCCCC::::CHH::::::H     H::::::HHRR:::::R     R:::::R *
  JJ:::::::::::::JJ    CC:::::::::::::::CH:::::::H     H:::::::HR::::::R     R:::::R *
    JJ:::::::::JJ        CCC::::::::::::CH:::::::H     H:::::::HR::::::R     R:::::R *
 *    JJJJJJJJJ             CCCCCCCCCCCCCHHHHHHHHH     HHHHHHHHHRRRRRRRR     RRRRRRR *
 *                                                                                   *
 * This file was generated by the K.U.Leuven JCHR System v1.6.0                      *
 * (available at http://www.cs.kuleuven.be/~petervw/JCHR/).                          *
 *                                                                                   *
 * Do not edit: edit the jchr-source file instead.                                   *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */



import runtime.Handler;
import runtime.IConstraint;
import runtime.Constraint;

import runtime.hash.HashIndex;
import runtime.hash.FDSSHashIndex;

import annotations.JCHR_Constraints;
import annotations.JCHR_Constraint;
import annotations.JCHR_Tells;

import util.Cloneable;
import runtime.ConstraintIterable;
import util.iterator.NestedIterator;
import util.iterator.NestedIterable;
import util.iterator.SingletonIterator;
import util.iterator.FilteredIterable;
import util.iterator.FilteredIterator;
import util.iterator.Filtered.Filter;
import util.iterator.EmptyIterator;
import util.collections.Empty;
import util.collections.AbstractUnmodifiableCollection;

import java.util.Collection;
import java.util.Iterator;

/* @javax.annotation.Generated(
	value = "The K.U.Leuven JCHR System v1.6.0",
	date = "2015-09-14T10:54:14.430+02:00",
	comments = "http://www.cs.kuleuven.be/~petervw/JCHR/") */
@JCHR_Constraints({
	@JCHR_Constraint(
		identifier = "gcd",
		arity = 1
	)
})
@SuppressWarnings("unused")	// eclipse-specific tag?
public class GcdHandler extends Handler {
	protected final runtime.ContinuationStack $$continuationStack;

	@Override protected final Continuation dequeue() { return super.dequeue(); }
	@Override protected final Continuation dequeue(Continuation continuation) { return super.dequeue(continuation); }
	@Override protected final void enterHostLanguageMode() { super.enterHostLanguageMode(); }
	@Override protected final void exitHostLanguageMode() { super.exitHostLanguageMode(); }

	public GcdHandler() {
		this(runtime.ConstraintSystem.get());
	}

	public GcdHandler(runtime.ConstraintSystem $$constraintSystem) {
		super($$constraintSystem);
		$$continuationStack = getContinuationStack();
	}

	@Override
	public String getIdentifier() {
		return "gcd";
	}

	@Override
	@SuppressWarnings("unchecked")
	public Class<? extends Constraint>[] getConstraintClasses() {
		return new Class[] {
			GcdConstraint.class
		};
	}

	/**
	 * {@inheritDoc}
	 *
	 * @see #lookupGcd()
	 */
	@Override
	@SuppressWarnings("unchecked")
	public Iterator<IConstraint> iterator() {
		return new util.iterator.ChainingIterator<IConstraint>(
			lookupGcd()
		);
	}

	/**
	 * {@inheritDoc}
	 *
	 * @see #lookupGcd()
	 */
	@Override
	@SuppressWarnings("unchecked")
	public Iterator<IConstraint> lookup() {
		return new util.iterator.ChainingIterator<IConstraint>(
			lookupGcd()
		);
	}

	GcdHandler includePackage() {
		return this;
	}
	protected GcdHandler includeProtected() {
		return this;
	}

	@JCHR_Tells(
		constraint = "gcd",
		warrantsStackOpimization = true
	)
	public final void tellGcd(long $0) {
		if ($$constraintSystem.inDefaultHostLanguageMode())
			call(new GcdConstraint($0));
		else if (!$$constraintSystem.isQueuing())
			$$continuationStack.push(new GcdConstraint($0));
		else
			$$continuationQueue.enqueue(new GcdConstraint($0));
	}

	private final runtime.DoublyLinkedConstraintList<GcdConstraint> $$gcdConstraintList = new runtime.DoublyLinkedConstraintList<GcdConstraint>();

	/**
	 * Adds the given {@link GcdConstraint} <code>constraint</code> to the
	 * constraint store.
	 *
	 * @param constraint
	 *  The constraint that has to be added to the constraint store.
	 *
	 * @pre <code>constraint != null</code>
	 * @pre The constraint is newer then all other constraints in the store.
	 *
	 * @see runtime.Constraint#isNewerThan(runtime.Constraint)
	 */
	void storeGcd(GcdConstraint constraint) {
		$$gcdConstraintList.addFirst(constraint);
	}

	final runtime.ConstraintIterable<GcdConstraint> lookupGcd_0_0() {
		return $$gcdConstraintList;
	}

	/**
	 * Returns an iterator over all <code>GcdConstraint</code>s currently
	 * in the constraint store. The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer very few guarantees about the behavior of these iterators:
	 * <ul>
	 *  <li>
	 *      There are no guarantees concerning the order in which the constraints 
	 *      are returned.
	 *  </li>
	 *  <li>
	 *      The iterators <em>might</em> fail if the constraint store is structurally modified
	 *      at any time after the <code>Iterator</code> is created. In the face of concurrent modification
	 *      it cannot recover from, the <code>Iterator</code> fails quickly and cleanly (throwing a
	 *      <code>ConcurrentModificationException</code>), rather than risking arbitrary, 
	 *      non-deterministic behavior at an undetermined time in the future.
	 *      <br/>
	 *      The <i>fail-fast</i> behavior of the <code>Iterator</code> is not guaranteed,
	 *      even for single-threaded applications (this constraint is inherited from the 
	 *      <a href="http://java.sun.com/j2se/1.5.0/docs/guide/collections/">Java Collections Framework</a>).
	 *      and should only be used to detect bugs. 
	 *      <br/>
	 *      Important is that, while <code>Iterator</code>s returned by collections of the 
	 *      Java Collections Framework generally &quot;fail fast on a best-effort basis&quot;, 
	 *      this is not the case with our <code>Iterator</code>s. On the contrary: our
	 *      iterators try to recover from structural changes &quot;on a best-effort basis&quot;,
	 *      and fail cleanly when this is not possible (or possibly to expensive). So,
	 *      in general you can get away with many updates on the constraint store during
	 *      iterations (there is no way of telling which will fail though...)
	 *  </li>
	 *  <li>
	 *      The failure of the <code>Iterator</code> might only occur some time after
	 *      the structural modification was done: this is again because many parts
	 *      of the constraint store are iterable in the presence of modification.
	 *  </li>
	 *  <li>
	 *      When a constraint is added to the constraint store after the creation of the
	 *      iterator it is possible it appears somewhere later in the iteration, but
	 *      it is equally possible it does not.
	 *  </li>
	 *  <li>
	 *      Removal of constraints on the other hand does mean the iterator will never return
	 *      this constraint.
	 *      Note that it still remains possible that the iterator fails somewhere after
	 *      (and because of) this removal.
	 *  </li>
	 * </ul>
	 * The lack of guarantees is intentional. Some <i>Iterator</i>s might behave perfectly 
	 * in the presence of constraint store updates, whilst others do not. Some might return
	 * constraints in order of their creation (and only iterate over constraints that existed
	 * at the time of their creation), others do not. In fact: it is perfectly possible that 
	 * their behavior changes between two compilations (certainly when moving to a new version
	 * of the compiler). This is the price (and at the same time the bless) of declarative 
	 * programming: it is the compiler that chooses the data structures that seem optimal 
	 * to him at the time!
	 *
	 * @return An iterator over all <code>GcdConstraint</code>s currently
	 * 	in the constraint store.
	 */
	public Iterator<GcdConstraint> lookupGcd() {
		return $$gcdConstraintList.iterator();
	}

	/**
	 * Returns an {@link Iterable} over all {@link GcdConstraint}s 
	 * currently in the constraint store, filtered by a user-provided filter. 
	 * The <code>Iterator.remove()</code> method is never supported.
	 * Besides that, we offer the same guarantees about the behavior of the iterators
	 * as the ones given by the {@link #lookupGcd()}.
	 * Also: if the condition the filter tests for is altered during an iteration,
	 * behavior is, as always, undefined.
	 *
	 * @param filter
	 *  A user defined filter that will be used to filter the iterated elements.
	 *
	 * @see #lookupGcd
	 */
	public Iterable<GcdConstraint> getGcdConstraints(Filter<? super GcdConstraint> filter) {
		return new FilteredIterable<GcdConstraint>($$gcdConstraintList, filter);
	}

	/**
	 * Returns (an unmodifiable view of) the current collection of 
	 * <code>GcdConstraint</code>s currently in the constraint store. 
	 * Iterators over this collection are the equivalents of those
	 * created by the <code>lookupGcd</code>-method.
	 * We refer to this method for more information on their behavior.
	 * This collection is backed by the constraint store: updates 
	 * to the store will be reflected in the collection.
	 *
	 * @return (An unmodifiable view of) the current collection of 
	 * 	<code>GcdConstraint</code>s currently 
	 *	in the constraint store. 
	 *
	 * @see #lookupGcd
	 */
	public Collection<GcdConstraint> getGcdConstraints()
 {
		// This implementation is still quite inefficient
		// (collection size has to be computed on-demand): 
		// best not to over-use this feature yet!
		return new AbstractUnmodifiableCollection<GcdConstraint>() {
			@Override
			public int size() {
				return util.iterator.IteratorUtilities.size(iterator());
			}

			@Override
			public Iterator<GcdConstraint> iterator() {
				return lookupGcd();
			}
		};
	}

	/**
	 * Reactivates all constraints of type <code>GcdConstraint</code>.
	 */
	public void reactivateGcdConstraints() {
		// NOP
	}

	/**
	 * Reactivates all constraints of type <code>GcdConstraint</code>
	 * that are not excluded by the provided filter.
	 *
	 * @param filter
	 *   A filter on the constraints to reactivate.
	 */
	public void reactivateGcdConstraints(util.iterator.Filtered.Filter<? super GcdConstraint> filter) {
		// NOP
	}

	/** {@inheritDoc} */
	@Override
	public void reactivateAll() {
		// NOP
	}

	/** {@inheritDoc} */
	@Override
	public void reactivateAll(util.iterator.Filtered.Filter<? super Constraint> filter) {
		// NOP
	}


	// This implementation is still very inefficient: 
	// don't over-use this feature yet!
	@Override
	public int size() {
		return util.iterator.IteratorUtilities.size(iterator());
	}
	
	@Override
	public boolean isEmpty() {
		return !iterator().hasNext();
	}

	/**
	 * Resets the handler, i.e. it terminates and removes all constraints
	 * from the constraint store.
	 * The resulting constraint store will be empty.
	 */
	public void reset() {
		terminateAll($$gcdConstraintList);
	}

	/* @javax.annotation.Generated(
		value = "The K.U.Leuven JCHR System v1.6.0",
		date = "2015-09-14T10:54:14.505+02:00",
		comments = "http://www.cs.kuleuven.be/~petervw/JCHR/"	) */
	@Constraint.Meta(
		identifier = "gcd",
		arity = 1,
		fields = {"$0"}
	)
	public final class GcdConstraint extends Constraint {
		GcdConstraint(long $0) {
			this.$0 = $0;
		}

		final long $0;
		public long get$0() { return this.$0; }

		protected void store() {
			if (!stored) {
				stored = true;
				ID = IDcounter++;
				storeGcd(GcdConstraint.this);
			}
		}

		@Override
		public final void reactivate() {
			// NOP
		}

		private StorageBackPointer $$storageBackPointers;

		@Override
		public void addStorageBackPointer(util.Terminatable x) {
			$$storageBackPointers = new StorageBackPointer($$storageBackPointers, x);
		}

		@Override
		protected final void terminate() {
			alive = false;

			if (stored) {
				stored = false;
				StorageBackPointer cursor = $$storageBackPointers;
				if (cursor != null) {
					$$storageBackPointers = null;
					do {
						cursor.value.terminate();
					} while ( (cursor = cursor.next) != null);
				}
			}
		}

		public final String getIdentifier() {
			return "gcd";
		}

		public final int getArity() {
			return 1;
		}

		public final Object[] getArguments() {
			return new Object[] {
				get$0()
			};
		}

		@SuppressWarnings("unchecked")
		public final Class<?>[] getArgumentTypes() {
			return new Class[] {
				java.lang.Long.TYPE
			};
		}

		public final String[] getInfixIdentifiers() {
			return new String[] {};
		}

		public final boolean hasInfixIdentifiers() {
			return false;
		}

		public final GcdHandler getHandler() {
			return GcdHandler.this;
		}

		protected final Continuation gcd_1() {
			long $0 = this.$0;
			if ($0==0) {
				this.terminate();
				return $$continuationStack.pop();
			}
			return null;
		}

		protected final Continuation gcd_2() {
			long M = this.$0;
			runtime.ConstraintIterable<GcdConstraint> gcd_3_lookup;
			gcd_3_lookup = lookupGcd_0_0();
			Iterator<GcdConstraint> gcd_3_iter;
			gcd_3_iter = gcd_3_lookup.existentialIterator();
			GcdConstraint gcd_3;
			while (gcd_3_iter.hasNext()) {
				gcd_3 = gcd_3_iter.next();
				long N = gcd_3.$0;
				if (M>=N) {
					this.terminate();
					return new GcdConstraint(LongUtil.mod(java.lang.Long.valueOf(M), java.lang.Long.valueOf(N)).longValue());
				}
			}
			return null;
		}

		protected final Continuation gcd_3() {
			long N = this.$0;
			runtime.ConstraintIterable<GcdConstraint> gcd_2_lookup;
			gcd_2_lookup = lookupGcd_0_0();
			Iterator<GcdConstraint> gcd_2_iter;
			gcd_2_iter = gcd_2_lookup.universalIterator();
			GcdConstraint gcd_2;
			while (gcd_2_iter.hasNext()) {
				gcd_2 = gcd_2_iter.next();
				if (this != gcd_2) {
					long M = gcd_2.$0;
					if (M>=N) {
						stored = true;
						ID = IDcounter++;
						storeGcd(GcdConstraint.this);

						gcd_2.terminate();
						if (gcd_2_iter.hasNext()) {
							$$continuationStack.push(new Gcd_3_1(gcd_2_iter));
						}
						return new GcdConstraint(LongUtil.mod(java.lang.Long.valueOf(M), java.lang.Long.valueOf(N)).longValue());
					}
				}
			}
			return null;
		}

		@Override
		protected Continuation call() {
			if (isAlive()) {
				Continuation continuation;
				if ((continuation = gcd_1()) != null) return continuation;
				if ((continuation = gcd_2()) != null) return continuation;
				if ((continuation = gcd_3()) != null) return continuation;
				if (!stored) {
					stored = true;
					ID = IDcounter++;
					storeGcd(GcdConstraint.this);
				}
			}
			return $$continuationStack.pop();
		}


		protected final class Gcd_3_1 extends Continuation {
			private final Iterator<GcdConstraint> gcd_2_iter;

			public Gcd_3_1(Iterator<GcdConstraint> gcd_2_iter) {
				this.gcd_2_iter = gcd_2_iter;
			}

			@Override
			protected Continuation call() {
				if (isAlive()) {
					Continuation continuation;
					if ((continuation = gcd_3_1(gcd_2_iter)) != null) return continuation;
				}
				return $$continuationStack.pop();
			}

			@Override
			public String toString() {
				return new StringBuilder()
					.append("Gcd_3_1")
					.append('(')
					.append("gcd_2_iter")
					.append(')')
					.toString();
			}
		}

		protected final Continuation gcd_3_1(Iterator<GcdConstraint> gcd_2_iter) {
			long N = this.$0;
			GcdConstraint gcd_2;
			while (gcd_2_iter.hasNext()) {
				gcd_2 = gcd_2_iter.next();
				if (this != gcd_2) {
					long M = gcd_2.$0;
					if (M>=N) {
						gcd_2.terminate();
						if (gcd_2_iter.hasNext()) {
							$$continuationStack.undoPop();
						}
						return new GcdConstraint(LongUtil.mod(java.lang.Long.valueOf(M), java.lang.Long.valueOf(N)).longValue());
					}
				}
			}
			return null;
		}

		@Override
		public String toString() {
			return new StringBuilder()
				.append("gcd(")
				.append($0)
				.append(')')
				.toString();
		}

		@Override
		@SuppressWarnings("unchecked")
		public boolean equals(Object other) {
			return (other instanceof GcdHandler.GcdConstraint)
			    && this.equals((GcdConstraint)other);
		}

		public boolean equals(GcdConstraint other) {
			if (this == other) return true;
			return this.$0==other.$0;
		}

		@Override
		public int hashCode() {
			int hashCode = 37 * (23) + (int)($0 ^ ($0 >>> 32));
			hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
			hashCode ^= (hashCode >>> 7) ^ (hashCode >>> 4);
			return hashCode + 102152;
		}
	}

	@Override
	public boolean isStored(Class<? extends IConstraint> constraintClass) {
		if (constraintClass == GcdConstraint.class)
			return true;
		throw new IllegalArgumentException(constraintClass.getSimpleName());
	}
}
